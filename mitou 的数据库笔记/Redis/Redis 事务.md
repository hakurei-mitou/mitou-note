# Redis 事务

Redis 事务用于一次性、顺序性、排他性地执行一系列命令，其他客户端提交的命令请求不会插入到当前事务执行命令序列中。

## 命令

- WATCH

	监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。

- MULTI 

	开启事务，redis会将后续的命令逐个放入队列中，然后可以使用 EXEC 命令来原子化执行这个命令序列。

- EXEC

	开始执行事务中的所有操作命令。

- DISCARD

	取消事务，放弃执行事务块中的所有命令。

- UNWATCH

	取消WATCH对所有key的监视。

## 事务出现错误时的处理

### 语法错误（编译器错误）

在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值。

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 11
QUEUED
127.0.0.1:6379> sets k2 22
(error) ERR unknown command `sets`, with args beginning with: `k2`, `22`, 
127.0.0.1:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379>
```

### Redis 类型错误（运行时错误）

在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时**事务并没有回滚，而是跳过错误命令继续执行**， 结果k1值改变、k2保留原值

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k1 v2
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 11
QUEUED
127.0.0.1:6379> lpush k2 22
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379> get k1
"11"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379>
```

## watch

Redis 可以使用 WATCH 监控某些键值对，然后使用 MULTI 命令开启事务。

这样，当使用 EXEC 执行事务时：

- 事务正式开始前首先比对 WATCH 监控的键值对
	- 如果没发生改变，它会执行事务队列中的命令，提交事务。
	- 如果有至少一个被监视的键发生变化，那么会取消执行事务中的任何命令，并返回 nil-reply 来表示事务已经失败。
- 无论事务是否成功执行，该 WATCH 命令使用过一次后会被撤销。
- Redis 是单线程的，事务开始后不会被其它命令（新的线程）干扰。

WATCH 属于对被监控键值对的乐观锁实现，不用加锁，只是检测值在事务开始前是否发生变化（碰撞）。

在程序中，可以使用自旋锁机制，不断重试 WATCH， 直到 WATCH 没有发生碰撞为止。

watch 使用示例：

在事务开始前用WATCH监控k1，之后修改k1为11，说明事务开始前k1值被改变，MULTI开始事务，修改k1值为12，k2为22，执行EXEC，发回nil，说明事务回滚；查看下k1、k2的值都没有被事务中的命令所改变。

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> WATCH k1
OK
127.0.0.1:6379> set k1 11
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 12
QUEUED
127.0.0.1:6379> set k2 22
QUEUED
127.0.0.1:6379> EXEC
(nil)
127.0.0.1:6379> get k1
"11"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379>
```

UNWATCH 使用示例：

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> WATCH k1
OK
127.0.0.1:6379> set k1 11
OK
127.0.0.1:6379> UNWATCH
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 12
QUEUED
127.0.0.1:6379> set k2 22
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
127.0.0.1:6379> get k1
"12"
127.0.0.1:6379> get k2
"22"
127.0.0.1:6379>
```

## 为什么 Redis 不支持回滚？

Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。

因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

## Redis 事务与 ACID

Redis 不像其它结构化数据库有隔离级别这种设计。

- 原子性 atomicity

	Redis 满足部分原子性。

	- 在事务回滚上，Redis 的运行期的错误不会回滚，这是违背原子性的。
	- 在命令执行上，Redis 事务所有的命令，要么全部执行，要么全部不执行，这满足原子性。

- 一致性 consistency

	事务中宕机时，Redis 只能保证部分一致性。

	- 事务中宕机，不会产生错误或者非法的数据。（满足约束一致性，数据合法）
	- 但是，宕机后事务已经执行的命令的数据会被恢复，但事务不会恢复，一个事务中多个命令将只生效一部分。（不满足完整一致性，数据不完整）

- 隔离性 Isolation

	Redis 事务严格遵守隔离性。

	- 原因是 redis 是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。

- 持久性 Durability

	Redis 事务不保证持久性。

	- 没有配置 RDB 或者 AOF 时，事务的持久性无法保证；
	- 使用了 RDB 模式，在一个事务执行后，下一次的 RDB 快照还未创建前，如果发生了实例宕机，事务的持久性同样无法保证；
	- 使用了 AOF 模式；AOF 模式的三种配置选项 no 、everysec 都会存在数据丢失的情况 。always 可以保证事务的持久性，但因为性能太差，在生产环境一般不推荐使用。
	- Redis 不保证持久性可以减少对性能的影响。（缓存不是数据库，缓存即使清空后仍然可以重建，缓存更重要的是性能）
