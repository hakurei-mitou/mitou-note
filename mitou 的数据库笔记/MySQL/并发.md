# 并发

## 事务

### 基本操作

- 查看事务提交方式

	`select @@autocommit;` 为 $0$ 代表手动，为 $1$ 代表自动。

- 设置事务提交方式

	`set @@autocommit = 0;`

- 开启事务

	`start transaction 或 begin;`

- 提交事务

	`commit;` 未提交时，数据库不会被更新。

- 回滚事务

	`rollback;` 出错时使用回滚。

### 事务四大特性

(ACID)

1. 原子性（ Atomicity ）
	一个事务要么全部完成，要么全部不完成，是一个不可分割的整体。
2. 一致性（ Consistency ）
	一个事务独立执行的结果应该保证不会破坏数据库，即保持数据库的一致性。
3. 隔离性（ Isolation ）
	多个事务并发执行时，与各事务先后单独执行的结果一样。即多个事务并发时，要保证执行结果是正确的。
4. 持久性（ Durability ）
	一个事务一旦完成（即提交或回滚），它对数据库的所有更新应永久地反映在数据库中。即使以后系统发生故障，也应有日志记录。

- 保证措施
	- 原子性：undo log
	- 一致性：undo log + redo log
	- 隔离性： 锁 + MVCC
	- 持久性：redo log

### 并发事务问题

常见后三个问题。

1. 丢失更新（ lost update ）
	第一个事务更新数据后，被第二个事务更新的数据所覆盖。
2. 读脏数据（ read dirty data ）（ 脏读 ）
	一个事务使用了另一个事务还没有提交的数据。
3. 不可重复读（ non-repeatable reads ）（ 不一致分析 ）
	一个事务连续两次读同一行数据，读到的数据不一样。即第二次读取了被其它事务更新了的数据。
4. 幻读（ phantom reads ）
	一个事物查询时没有发现对应的数据行，而后插入时又发现该行已存在（发生主键冲突）。
	- 一般查询是查询快照（快照读），而更新是直接作用于原表（当前读），当原表被并发事务修改，而当前事务快照没有更新，从而产生幻读。

### 事务隔离级别

- 未提交读（Read uncommitted，RU）

	隔离事务的最低级别，只能保证不读取物理上损坏的数据。不能避免问题。

- 已提交读（Read committed，RC）

	SQL Server 的默认级别。可避免脏读。

- 可重复读（Repeatable Read，RR）

	MySQL 的默认级别。可避免脏读，不可重复读。

- 可序列化（Serializable，S）

	隔离事务的最高级别，事务之间完全隔离。可避免脏读，不可重复读，幻读。

隔离级别越高，安全性越高，但性能越低。

```sql
查看事务隔离级别
select @@transaction_isolation;

设置事务隔离级别
set [session | global]   # session 代表当前会话
transaction isolation level <隔离级别的英文>
```

问题产生的条件与隔离级别相关联：

- Read uncommitted

	自动提交事务。

- Read committed

	需手动提交事务。

- Repeatable Read

	事务操作备份，只要当前事务未提交，则当前事务同样的语句产生的结果一致。

- Serializable

	当前事务完成后（提交后），其余事务才能执行，否则处于等待状态。这样保证了读到的数据都是最新的。

## 锁

### 全局锁

锁定数据库中的所有表。加锁后处于只读状态，写操作被阻塞。（一般在备份数据库时使用）

### 表级锁

每次操作锁定整张表。

#### 表锁

- 表共享读锁（read lock）

	所有客户端只允许读，其它操作阻塞。（共享）

- 表独占写锁（write lock）

	当前客户端可读可写，其它客户端不可读不可写。（排他）

```sql
lock tables 表名... read/write; # 加锁

unlock tables; 或者断开客户端连接   # 释放锁
```

#### 元数据锁

（meta data lock，MDL）

MDL 有系统自动控制，访问一张表时会自动加上，用于维护元数据的一致性，加上后不可以对元数据进行写入操作。

元数据相当于表结构，即在有活动事务时，不允许修改表结构。

- 当对一张表进行增删改查的时候，加 MDL 读锁（共享）;
- 当对表结构进行变更操作的时候，加 MDL 写锁（排他）。

#### 意向锁

为了避免 DML 在执行时自动加的行锁与将要加的表锁产生冲突，InnoDB 引入了意向锁，使得表锁不必检查每行数据是否加了行锁，使用意向锁减少表锁的检查。

- 语句在执行时，自动加行锁，再对表加意向锁，当另一个进程要对该表加表锁时，直接检查意向锁，查看是否与表锁冲突，若冲突则阻塞。
	- DQL 语句默认不加任何锁。
	- DML 语句默认加意向排他锁。

- 意向共享锁（IS）

	与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。

	```sql
	select ... lock in share mode   # 加行锁共享锁，同时为表加意向共享锁
	```

- 意向排他锁（IX）

	与表锁共享锁（read）和表锁排他锁（write）都互斥，意向锁之间不会互斥。

	```sql
	insert, update, delete 自动添加
	
	select ... for update 手动添加
	```

### 行级锁

每次操作锁定行级别的数据。

#### 行锁

（Record Lock）

防止其它事务对该行进行 update 或 delete 操作。在 RC、RR 隔离级别下都支持。

- 共享锁（S）

	允许一个事务去读一行，组织其它事务获得相同数据集的排它锁。

- 排他锁（X）

	允许获取排他锁的事务更新数据，阻止其它事务获得相同数据集的共享锁和排他锁。

InnoDB 的数据是有索引组织的，行锁是通过在索引项加锁实现的，而不是对记录加锁。

- InnoDB 在 RR 隔离级别下默认使用 next-key 锁（临建锁）进行搜索和索引扫描，以防止幻读
	- 通过唯一索引进行检索时，若对已存在的记录进行等值匹配，将会自动优化为行锁。
	- 若不通过索引检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会**升级为表锁**。（不通过索引就要扫描）

#### 间隙锁

（Gap Lock）

锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其它事务在这个间隙进行 insert 产生幻读，（**主要避免幻读**）。在 RR 隔离级别下都支持。

- 索引上的等值查询（唯一索引）

	给不存在的记录加锁时，加间隙锁。

- 索引上的等值查询（普通索引）

	在查询到最后一个满足查询需求的值时，next-key lock 退化为间隙锁。（对该值前一个间隙和后一个间隙加间隙锁，该值的后一个间隙也即是该值后一个值的前一个间隙）

- 索引上的范围查询（唯一索引）

	访问到不满足条件的第一个值则停止。

间隙锁可以共存，多个事务可叠加对统一间隙加间隙锁。

#### 临键锁

（Next-Key Lock）

行锁和间隙锁组合，锁住数据和数据前面的间隙。在 RR 隔离级别下支持。

## MVCC

多版本并发控制（Multiversion Concurrency Control， MCC 或 MVCC）

### 读方式

- 当前读

	读取的是记录的最新版本，读取时要保证其它事务不会修改记录，会对读取的事务加锁。

	```sql
	# 共享锁
	select ... lock in share mode
	
	# 排他锁
	select ... for update
	update
	insert
	delete
	
	# 以上都是当前读
	```

- 快照读

	简单的 select 语句（不加锁）就是快照读，读取的是记录的可见版本，有可能是历史数据，不加锁，是非阻塞读。

	- Read Commited： 每次 select 都生成一个快照，能读取到最新数据。
	- Repeatable Read：开启事务后第一个 select 产生一个快照，后续 select 都读取该快照，可能不是最新数据。
	- Serializable：快照读退化为当前读，每一次读取都加锁。

### 隐藏字段

MySQL 自动为表添加三个隐藏字段。

- `DB_TRX_ID`

	最近修改事务 ID，记录插入这条记录或最后一次修改该条记录的事务 ID 。

- `DB_ROLL_PTR`

	回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本。（undo log 用于数据回滚）

- `DB_ROW_ID`

	隐藏主键，如果表结构没有指定主键，将会生成该字段。

### Undo log 版本链

Undo log 记录的更改前记录，每一个版本的记录的 DB_ROLL_PTR 指向其上一个版本，构成 undo log 版本链。

（略）

### Readview

定义了 undo log 版本链的访问规则用以回滚。

（略）
