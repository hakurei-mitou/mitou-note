# 算法技巧及注意事项

## 项目结构

### 基本结构

- 项目说明

	- 背景
	- 数据
	- 目标
	- 策略

- 空间分析（预先分析）

	分析数据与模型的空间，构建满足空间条件的策略实现代码。

	- 外存

	- 内存

	- 显存

- 导入包

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import math
import os

import torch
import torch.nn as nn
from torch.utils.data import random_split, Dataset, DataLoader
```

- 配置参数

	使用 `Config` 类，设置类变量保存配置参数和超参数。（使用字典则无代码提示）

```python
class Config:   # 配置类
    # environment
    device = 'cuda' if torch.cuda.is_available() else 'cpu'   # 类变量
    seed = 923
    save_path = './model.ckpt'
    
    # data path
    data_path = './data'
    
    # NN structure
    
    # ...
    
    # training
    n_example = math.inf
    n_epoch = 1000
    early_stop_epoch = 300
    batch_size = 256
     
    # local or cloud
    here_path = os.getcwd()
    if 'kaggle/working' in here_path: 
        # cloud items
    else:
        # local items
        
	# local or could runing test
    runing_test = True   # need be modified by hand
    if runing_test:   # 尽量把需要频繁修改的项放在底部
	    n_example = 10
    	n_epoch = 10
    
    # 必要时可扩展
	def __init__(self):   
        pass

print(f"Using {Config.device} device")

# 扩展
class ConfigTest:
    pass
```

- 通用操作

```python
def same_seed(seed): 
    torch.backends.cudnn.deterministic = True   # 卷积都使用默认的卷积算法
    torch.backends.cudnn.benchmark = False   # 关闭系统卷积算法选择优化（带随机性）
    np.random.seed(seed)   # 为随机算法设置种子。
    torch.manual_seed(seed)   # 为 CPU 设置种子。
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(seed)   # 为所有 GPU 设置种子。

def split_train_valid(data, valid_ratio, seed):
    valid_size = int(len(data) * valid_ratio)
    train_size = len(data) - valid_size
    train_set, valid_set = random_split(data, [train_size, valid_size], generator=torch.Generator().manual_seed(seed))
    return train_set, valid_set
```

- 数据处理

- 模型结构

- 训练流程

- 输出统计信息

- 绘图

- 测试、预测

- 时间分析（运行时分析）

	进行时间测试，反复修改代码以提升效率。

	- 数据处理时间
	- 训练时间
	- 测试时间

### 工程风格

使用 main 函数统筹各部分函数：

- 便于清晰描述项目流程，也便于结合 Config 扩展到多参数对比训练。
- 简明，模块化，易扩展，但不便于反复调试，每次调试都要重复计算。

```python
def main():
	same_seed(Config.seed)
	...
	...
    
main()   # begin code

# 扩展
# def project()
Config.xxx
main(xxx)
Config.xxx
main(xxx)
```

### Jupyter Notebook 风格

不再使用 main 函数统筹函数，而是直接使用 Jupyter Cell 统筹流程：

- 不必每次调试都从头开始运行，可以反复利用已经计算出的结果，和输出测试信息。
- 变量命名要准确，Notebook 风格会存在大量全局变量。

整体结构顺序要按照基本结构布置，便于修改为函数或类，从而扩展到工程风格。

## 输出刷新

原生方法只能单行刷新，多行刷新需要使用库。

- `\r` 可以移动到当前行开头，从而刷新输出。
- 刷新的行不能有换行符，可在 `print()` 内指定 `end=''` 。
- 刷新行后的第一个非刷新行需要在开头添加换行符。

```python
print(f'\r[{epoch + 1}/{Config.n_epoch}] train loss = {train_mean_loss:4f}, valid loss = {valid_mean_loss:.4f}', end='')

print(f'\n[{epoch + 1}/{Config.n_epoch}] save model : train loss = {train_mean_loss:.4f}, valid loss = {valid_mean_loss:.4f}')
```

## Kaggle 使用

基本使用

关闭页面前要关闭 session ，否则会一直占用运行时长到一个小时超时。

GPU 使用

内存使用

## 空间控制

- 训练前计算大概的内存。
- 及时回收无用的变量。
- 训练时逐步读取。

## 时间控制



## 杂项

- 测试数据在测试时再构建。

- PyTorch 中方法名末尾如果带下划线，表示会修改变量本身（in-place）：`.abs_(), .abs()  ` 。
- 编码测试使用小部分数据集和小参数，测试完后再正式训练。
- `assert` 可用于调试。
- 可跑一个 epoch 或一个 batch 以预估总训练时间。
- 云端和本地都要运行测试，因为云端可能有 GPU 等环境问题。