# 杂项算法

## 快读快写

快读快写一般用不上，scanf 与 printf 在大部分情况下都足够。

依据 getchar 比 scanf 快，putchar 比 printf 快，具体实现要以具体情况改变。 

### 快读

```c++
// 对于只包含 数字、空格、负号 的情况。

inline int fastRead() {
    int s = 1, x = 0;   // 符号，绝对值
    char ch;
    while (ch = getchar()) {
        if (ch != ' ') {   // 跳过空格
            if (ch == '-') {   // 遇到负号
                s = -1;
            }
            while (ch = getchar()) {   // 读入数字，累计数值
                x = x*10 + ch - '0';
            }
            return s*x;   // 返回真值
        }
    }
}
```

### 快写

```c++
// 对于只包含 数字、空格、负号 的情况。

inline void fastWrite(int x) {   // 未考虑空格输出
    char str[20];
    int len = -1;
    if (x < 0) {
        putchar('-');
        x = ~x + 1;   // 等同于 x = -x;
    }
    do {    // 若使用 while 循环，则 x = 0 时要额外操作
        str[++len] = x % 10 + '0';
        x /= 10;
    } while (x > 0);
    for (int i = len; i >= 0; --i) {   // 倒序输出
        putchar(str[i]);
    }
    return;
}
```

##  循环控制式

循环控制很宽泛，不要局限于以下用法。

注意 $i$ 的初值的影响。

### 取余类

#### 正向

- `i = i % a + 1;`

	$i$ 将在 $[1, a]$ 内不断循环。

- 泛化：`i = i % a + b;`

	$i$ 将在 $a$ 个整数组成的 $[1, a]$ 内不断以 $b$ 为间隔循环。

- 注意：

	- 若 $i$ 的初值大于等于 $a$，则循环将从 $0$ 开始。
	- 若 b 为 2，不能代表偶数，因为间隔选取的起始值不定，同时末尾值可能摆动。
	- 在 $b > 1$ 时，末尾值甚至可能跳出循环区间。 

---

- `i = (++i % a);`

	$i$ 将在 $[0, a-1]$ 内不断循环。
	
	可用于起始点不定，但要将 $[0, a-1]$ 范围都循环完的情形，第二次到 $i$ 退出即可。

- `i = (i++ % a);`

	$i$ 将在 $[1, a]$ 内不断循环。

---

- 引入第二变量 $j$，平移循环范围。

	对于:
    ```c++
    i = i % a + 1;
    j = i + 2;
    ```
  
    $i$ 将在 $[1, a]$ 内不断循环。$j$ 将在 $[3, a+2]$ 内不断循环。

#### 逆向

- `i = ( --i + a ) % a`
	
	$i$ 将在 $[0, a-1]$ 间不断逆循环。
	
	==$+a$ 是为了防止循环中出现负数。==

---

- 引入第二变量 $j$，平移循环范围。
	
	对于：
	```c++
	i = (--i + a) % a;
	j = i + 1;
	```
	
	$j$ 将在 $[1, a]$ 间不断逆循环。

---

- 若需要任意区间内的循环值

	- 先计算区间长度，有几个数 a 就是几。
	- 再设定一个额外的变量，用加法来平移循环区间。

- 若需要二倍关系的 $2$ 个值的不断循环

	令 a 为 b 的两倍即可：
	
	```c++
	for( int i = 0, j = 0; i < 100; i++ ){
	    j = j % 8 + 4;
	    printf("%d  ", j );
	}
	
	// 输出 4 8 4 8 4 8 4 8 ...
	```
	
- 若需要多个无规律值的不断循环

	将各值存入数组中，控制其下标即可。
	
- 若要进行循环退出

	- 增加变量，控制循环执行次数。
	- 扩大循环范围，增加一个循环的数作为终止循环标志。

#### 双向

```c++
int walk(int p, int d) {   // 初始位置，移动距离（正向右，负向左）
    p = (p + d + (abs(d)/n+1)*n) % n;    // (abs(d)/n+1)*n 使得取余运算一定不会出现负数。
    return p;   // 返回新的位置。 可返回 P + 某个数 来平移循环区间。
}
```

上面的代码对了应对 $d$ 为非常大的负数的情况，牺牲了很多效率，可以将正负分开处理以提升效率。

### 条件类

需要 $i, j$ 两个变量或更多变量。

==常用到条件表达式（三目运算符），逗号运算符。==

可用条件类模拟取余类对循环的控制

#### 对称

`(j < N ? i++ : i--), j++;`

$i$ 将在 $j$ 的范围内递增后递减。

这里是 ++，可以加其它数值，甚至加变量。

还可以嵌套条件表达式。

==注意括号的使用，防止条件表达式与逗号运算符引起语法混乱或错误。==

#### 复位

`（ i < N ? i++ : i = 0 ）`
i 将循环出现。

### 函数类

将各种复杂操作写为一个函数。

### 例题

输入一个数，输出对应的格式的菱形。

```c++
输入：
4

输出：
   1
  121
 12321
1234321
 12321
  121
   1
```

```c++
#include<iostream>

int main() {
    int N;
    std::cin>> N;
    for( int i = 1, j = 1; j < 2*N; ( j < N ? i++ : i-- ), j++ ) {   // i 控制每行中最大的数字， j 控制行数
        for( int k = 1; k <= N-i; k++ ){   //每行前输出空格（N-i）个
            std::cout<<' ';   //注意 i 与 j 的关系
        }
        for( int k = 1, m = 1; m < 2*i; ( m < i ? k++ : k-- ), m++ ) {   // k 控制输出的数字递增后减少，m 控制一行输出数字的个数
            std::cout<< k;   //注意 k 与 m 的关系，注意 i 值 
        }
        std::cout<<'\n';
    }
    return 0;
}
```

**以上程序最大支持一位数**

**因为当最大数超过一位，输出就会变形**

输入20的结果：

<img src="images/杂项算法/clipboard.png" alt="img" style="zoom: 80%;" />

下方是自动右对齐，支持任意位数：

关键在于统一了每一项的宽度，为便于看清，额外添加了数与数间的空格。

```c++
#include <cstdio>

int breadth(int n) {
    int count = 0;
    while( n > 0 ) {
        count++;
        n /= 10;
    }
    return count;
}

int main() {
    int N;
    scanf("%d", &N);
    for( int i = 1, j = 1, w = breadth(N); j < 2 * N; (j < N ? i++ : i--), j++) {
        for( int k = 1; k <= N - i; k++ ) {
            printf("%*c ", w, ' ' );   //注意，这里指定了空格的宽度
        }
        for( int k = 1, m = 1; m < 2 * i; (m < i ? k++ : k--), m++) {
            printf("%*d ", w, k );
        }
        putchar('\n');
    }
    return 0;
}
```

![img](images/杂项算法/clipboard-1618756484857.png)

如果输入的数过大，屏幕可能放不下……