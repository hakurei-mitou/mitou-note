# 杂项算法

## 快读快写

快读快写一般用不上，scanf 与 printf 在大部分情况下都足够。

依据 getchar 比 scanf 快，putchar 比 printf 快，具体实现要以具体情况改变。 

### 快读

```c++
// 对于只包含 数字、空格、负号 的情况。

inline int fastRead() {
    int s = 1, x = 0;   // 符号，绝对值
    char ch;
    while (ch = getchar()) {
        if (ch != ' ') {   // 跳过空格
            if (ch == '-') {   // 遇到负号
                s = -1;
            }
            while (ch = getchar()) {   // 读入数字，累计数值
                x = x*10 + ch - '0';
            }
            return s*x;   // 返回真值
        }
    }
}
```

### 快写

```c++
// 对于只包含 数字、空格、负号 的情况。

inline void fastWrite(int x) {   // 未考虑空格输出
    char str[20];
    int len = -1;
    if (x < 0) {
        putchar('-');
        x = ~x + 1;   // 等同于 x = -x;
    }
    do {    // 若使用 while 循环，则 x = 0 时要额外操作
        str[++len] = x % 10 + '0';
        x /= 10;
    } while (x > 0);
    for (int i = len; i >= 0; --i) {   // 倒序输出
        putchar(str[i]);
    }
    return;
}
```

##  循环控制式

循环控制很宽泛，不要局限于以下用法。

注意 $i$ 的初值的影响。

### 取余类

#### 正向

- `i = i % a + 1;`

	$i$ 将在 $[1, a]$ 内不断循环。

- 泛化：`i = i % a + b;`

	$i$ 将在 $a$ 个整数组成的 $[1, a]$ 内不断以 $b$ 为间隔循环。

- 注意：

	- 若 $i$ 的初值大于等于 $a$，则循环将从 $0$ 开始。
	- 若 b 为 2，不能代表偶数，因为间隔选取的起始值不定，同时末尾值可能摆动。
	- 在 $b > 1$ 时，末尾值甚至可能跳出循环区间。 

---

- `i = (++i % a);`

	$i$ 将在 $[0, a-1]$ 内不断循环。
	
	可用于起始点不定，但要将 $[0, a-1]$ 范围都循环完的情形，第二次到 $i$ 退出即可。

- `i = (i++ % a);`

	$i$ 将在 $[1, a]$ 内不断循环。

---

- 引入第二变量 $j$，平移循环范围。

	对于:
    ```c++
    i = i % a + 1;
    j = i + 2;
    ```
  
    $i$ 将在 $[1, a]$ 内不断循环。$j$ 将在 $[3, a+2]$ 内不断循环。

#### 逆向

- `i = ( --i + a ) % a`
	
	$i$ 将在 $[0, a-1]$ 间不断逆循环。
	
	==$+a$ 是为了防止循环中出现负数。==

---

- 引入第二变量 $j$，平移循环范围。
	
	对于：
	```c++
	i = (--i + a) % a;
	j = i + 1;
	```
	
	$j$ 将在 $[1, a]$ 间不断逆循环。

---

- 若需要任意区间内的循环值

	- 先计算区间长度，有几个数 a 就是几。
	- 再设定一个额外的变量，用加法来平移循环区间。

- 若需要二倍关系的 $2$ 个值的不断循环

	令 a 为 b 的两倍即可：
	
	```c++
	for( int i = 0, j = 0; i < 100; i++ ){
	    j = j % 8 + 4;
	    printf("%d  ", j );
	}
	
	// 输出 4 8 4 8 4 8 4 8 ...
	```
	
- 若需要多个无规律值的不断循环

	将各值存入数组中，控制其下标即可。
	
- 若要进行循环退出

	- 增加变量，控制循环执行次数。
	- 扩大循环范围，增加一个循环的数作为终止循环标志。

#### 双向

```c++
int walk(int p, int d) {   // 初始位置，移动距离（正向右，负向左）
    p = (p + d + (abs(d)/n+1)*n) % n;    // (abs(d)/n+1)*n 使得取余运算一定不会出现负数。
    return p;   // 返回新的位置。 可返回 P + 某个数 来平移循环区间。
}
```

上面的代码对了应对 $d$ 为非常大的负数的情况，牺牲了很多效率，可以将正负分开处理以提升效率。

### 条件类

需要 $i, j$ 两个变量或更多变量。

==常用到条件表达式（三目运算符），逗号运算符。==

可用条件类模拟取余类对循环的控制

#### 对称

`(j < N ? i++ : i--), j++;`

$i$ 将在 $j$ 的范围内递增后递减。

这里是 ++，可以加其它数值，甚至加变量。

还可以嵌套条件表达式。

==注意括号的使用，防止条件表达式与逗号运算符引起语法混乱或错误。==

#### 复位

`（ i < N ? i++ : i = 0 ）`
i 将循环出现。

### 函数类

将各种复杂操作写为一个函数。

### 例题

输入一个数，输出对应的格式的菱形。

```c++
输入：
4

输出：
   1
  121
 12321
1234321
 12321
  121
   1
```

```c++
#include<iostream>

int main() {
    int N;
    std::cin>> N;
    for( int i = 1, j = 1; j < 2*N; ( j < N ? i++ : i-- ), j++ ) {   // i 控制每行中最大的数字， j 控制行数
        for( int k = 1; k <= N-i; k++ ){   //每行前输出空格（N-i）个
            std::cout<<' ';   //注意 i 与 j 的关系
        }
        for( int k = 1, m = 1; m < 2*i; ( m < i ? k++ : k-- ), m++ ) {   // k 控制输出的数字递增后减少，m 控制一行输出数字的个数
            std::cout<< k;   //注意 k 与 m 的关系，注意 i 值 
        }
        std::cout<<'\n';
    }
    return 0;
}
```

**以上程序最大支持一位数**

**因为当最大数超过一位，输出就会变形**

下方是自动右对齐，支持任意位数：

关键在于统一了每一项的宽度，为便于看清，额外添加了数与数间的空格。

```c++
#include <cstdio>

int breadth(int n) {
    int count = 0;
    while( n > 0 ) {
        count++;
        n /= 10;
    }
    return count;
}

int main() {
    int N;
    scanf("%d", &N);
    for( int i = 1, j = 1, w = breadth(N); j < 2 * N; (j < N ? i++ : i--), j++) {
        for( int k = 1; k <= N - i; k++ ) {
            printf("%*c ", w, ' ' );   //注意，这里指定了空格的宽度
        }
        for( int k = 1, m = 1; m < 2 * i; (m < i ? k++ : k--), m++) {
            printf("%*d ", w, k );
        }
        putchar('\n');
    }
    return 0;
}
```

如果输入的数过大，屏幕可能放不下……

## 螺纹遍历

一般用于 grid 中。

对于 n 行 m 列，从左上角开始，结束点为 `[n/2][m/2]` ；

探路标记法：

```c++
#include <cstdio>
#include <cstring>

const int N = 20;
const int M = 20;
int grid[N][M];
int to_x[] = {0, 1, 0, -1};   // 遍历方向：右 -> 下 -> 左 -> 上
int to_y[] = {1, 0, -1, 0};

int main() {
    int n = 8, m = 9;

    bool visited[n][m] = {false};
    int x = 1, y = 0;   // 让第一个遍历点为 (1, 1)
    while (true) { // 不停走
        bool end = true;   // 退出标记
        for (int i = 0; i < 4; ++i) {   // 遍历四个方向
            while (true) {   // 每个方向一直走
                x += to_x[i];
                y += to_y[i];
                if (1 <= x && x <= n && 1 <= y && y <= m && !visited[x][y]) {   // 当前方向出界或已访问过
                    printf("%d ", grid[x][y]);
                    visited[x][y] = true;
                    end = false;
                } else {
                    // 退回一步
                    x -= to_x[i];
                    y -= to_y[i];
                    break;   // 当前方向停止
                }
            }
        }
        if (end) {   // 四个方向都走不动了，则退出
            break;
        }
    }
}
```

无标记，纯下标方法：

```c++
#include <cstdio>
#include <cstring>

const int N = 20;
const int M = 20;
int grid[N][M];
int to_x[] = {0, 1, 0, -1};   // 遍历方向：右 -> 下 -> 左 -> 上
int to_y[] = {1, 0, -1, 0};
int length[] = {m, n - 1, m - 1, n - 2};   // 右下左上的初始长度

int main() {
    int n = 8, m = 9;

    
    int x = 1, y = 0;
    for (int i = 0; true; i = ++i % 4) {   // 不断循环转向数组
        bool end = true;
        for (int j = 1; j <= length[i]; ++j) {   // 方向的长度（步数）
            x += to_x[i];
            y += to_y[i];
            end = false;
            printf("%d ", grid[x][y]);
        }
        length[i] -= 2;   // 长度一次减 2
        if (end) {   // 如果四个方向都没有 长度 了，退出
            break;
        }
    }

}
```

## 所有子区间和

- 方法 1，前缀和数组 + 穷举子区间。（$O(n^2)$）
- 方法 2，求每个元素出现在了多少个子区间中。（$O(n)$）

对于元素 `arr[i]` ，在从 `0` 到 `i` 之间选起点（`i +1` 位置），以及从 `i` 到 `n-1` 之间选终点时（` n - 1 - i + 1 ` 个位置），这个元素都会包含在子区间内，所以它所在的子区间数量为 `(i + 1) * (n - i)` 。

总的数量遍历元素即可：

```
total_sum = 0
for i from 0 to n-1:
    total_sum += arr[i] * (i + 1) * (n - i)
```





