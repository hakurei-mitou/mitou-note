# 双指针

双指针不是特定某种算法，是一系列技巧的合称。

## 快慢指针

主要解决链表上的某些问题。

### 链表中是否有环

设置两个指针，一快（$A$）一慢（$B$），（一般将 $A$ 的单位速度设为 $2$，$B$ 为 $1$）若 $A,B$ 相遇，则有环，如果 $A$ 先到达链表末尾，则无环。

可以将经过的结点的地址记录下来，看是否重复。

### 返回环的起始位置

需已知有环。

当 $A,B$ 相遇时，将 $B$ 重新指向头结点，然后以同样的速度运行，当 $A,B$ 再次相遇时，相遇位置即为所求。

#### 原理

王道 P57

### 确定链表中点

令 $A$ 一次前进两步， $B$ 一次前进一步，当 $A$ 到达链表末尾时，$B$ 即在链表中点。

当链表的长度是奇数时，$B$ 恰巧停在中点位置；如果长度是偶数，$B$ 的位置依代码实现不同中间偏左或偏右。

寻找链表中点的一个重要作用是对链表进行归并排序（要对其从中点二分）。

### 寻找链表倒数第 $k$ 个元素

让 $A$ 先走 $k$ 步，然后，$A,B$ 同速运行，当 $A$ 到达链表末尾时，$B$ 即在所求位置。

## 相向指针

### 二分查找

详见二分专题笔记。

### 反转数组

即是前后不停向内交换。

### 两数之和

给定一个数组，和一个数 $N$，要求在数组中找到所有满足 $a+b=N$ 的数对 $(a, b)$。

先排序，然后数组起点和终点各设置一个 $A,B$ 指针，若 $A+B<N$ 则 $A$ 右移，若 $A+B>N$ 则 $B$ 左移。

也可先排序，然后依次遍历元素，对每个元素 $x$，二分查找 $N-x$。

### 三数之和

给定一个数组，和一个数 $N$，要求在数组中找到所有满足 $a+b+c=N$ 的 $(a, b,c)$。

枚举 $a,b$，不必枚举 $c$，$c$ 可由 $N-a-b$ 得出。

## 滑动窗口（尺取法）

一种枚举区间的方法，在一定情况下可以缩减循环层数，将 $O(N^m)$ 变为 $O(N^{m-1})$。

### 情况

- 知道上一个区间状态和单个元素的变化就能推出新的区间状态的情况。
- **左右指针移动**时，**区间状态**具有某种**单调性**。
- 左右指针不可能同时移动。
- 左右指针都要枚举，但都是单调移动的，故不是 $O(n^2)$ ，而是 $O(n)$ 。

### P1638 逛画展

https://www.luogu.com.cn/problem/P1638

#### 分析

cnt 数组记录各种画的数量，根据数量的临界状态可以判断画家人数（painter）的变化。（区间状态）

- 当 R 向右移动，painter 不可能减小。（单调）
- 当 L 向右移动，painter 不可能增大。（单调）
- L 和 R 交替移动。（不同步）

#### AC 代码

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

const int MAXN = 1e6+5;
const int MAXM = 2005;
int N, M;
int arr[MAXN], cnt[MAXM];
int cost = __INT_MAX__;

int main() {
	scanf("%d %d", &N, &M);
	for (int i = 1; i <= N; ++i) {
		scanf("%d", arr+i);
	}
	int L = 1, R = 0;   // 双闭区间，注意初值，L 后++，R 先++，根据实际操作选择初值。
	int posL, posR;
	int painter = 0;
	while (L <= N) {   //  控制 L 的范围
		while (painter < M && R < N) {   // R 先++，所以 R < N 而不是 R <= N
			if (++cnt[arr[++R]] == 1) {
				++painter;
			}
		}   // 该循环结束后 painter 的值应当满足要求，若不满足，要提前退出。
		if (painter < M) {   // R 的扩增无法使 painter 达到要求，那么 L 就更不可能达到要求。
			break;   // 此处若不退出，则下方更新答案的语句可能会出错。
		}
		if (R-L+1 < cost) {   // 最小价值，记录区间端点
			cost = R-L+1;
			posL = L;
			posR = R;
		}
		if (--cnt[arr[L++]] == 0) {   // 此处 L++ 后可能越界，因此外层循环 L <= N
			--painter;
		}
	}
	printf("%d %d", posL, posR);
	return 0;
}
```

左右指针的移动写法以具体移动方式为准。
