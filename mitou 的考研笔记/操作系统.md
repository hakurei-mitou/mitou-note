# 操作系统

本笔记只列出少量要点、易错点及技巧，主要还是看书。



## 专题总结

#### 简图

- 甘特图

	用于进程调度场景。

	- 一图可多进程。
	- 多资源（CPU 是计算资源）可微微错位划线标识，标识好时间长度和使用什么资源（简要表示）。
	- 纵向虚线标识关键时间点。
	- 复杂情况最好标上刻度。

#### 二进制运算技巧

- 进制划分从低到高划分。
- 8421
- 十进制转二进制的一种方法 王道P157
- 二进制十进制混合运算 王道P179.5
- 十六进制转二进制



## 杂项

- 相联存储器（关联存储器）常用来构建快表、cache 。
- 相邻逻辑页在物理上不一定相邻，所以数组元素的物理地址空间可能不连续。





## 操作系统概论

### 基本概念

- 操作系统的基本特征
	- 并发
	- 共享
		- 互斥共享
		- 同时共享
	- 虚拟
		- 时分复用技术
		- 空分复用技术
	- 异步
	- 注意
		- 并发和共享是操作系统最基本的特征。
		- 并发和共享互为前提 王道P3
- 操作系统的功能
	- 处理机管理
		- 进程控制
		- 进程同步
		- 进程通信
		- 死锁处理
		- 处理机调度
	- 存储器管理
		- 内存分配与回收
		- 地址映射
		- 内存保护与共享
		- 内存扩充
	- 文件管理
		- 文件存储空间管理
		- 目录管理
		- 文件读写管理与保护
	- 设备管理
		- 缓冲管理
		- 设备分配
		- 设备处理
		- 虚拟设备
	- 提供接口
		- 命令接口
			- 联机命令接口（也叫交互式命令接口）
			- 脱机命令接口（也叫批处理命令接口）
		- 程序接口
			- 由一组系统调用（也叫广义指令）组成。

- 注意
	- 系统调用可以被库函数封装后呈现，但系统调用不等同于库函数，库函数也不止包含系统调用。

### 操作系统的发展与分类

#### 发展历程

- 手工阶段（此时无操作系统）
- 脱机处理（无操作系统）
- 单道批处理系统
- 多道批处理系统
	- 程序和 IO 间具备一定程度的并发性。
	- 多道的操作系统都依赖中断技术实现。
- 分时系统（Sharing TIme）
	- 时间片机制，可实现一定程度的人机交互。
	- liunx 和 Unix 是分时系统
- 实时系统（Real Time）
	- 硬实时系统
	- 软实时系统
- 网络操作系统
	- 计算机间的资源共享和通信。
- 分布式操作系统
	- 多台计算机的协同运行，基于网络操作系统。
- 其它
	- 个人计算机操作系统
	- 嵌入式操作系统
	- 服务器操作系统
	- 智能手机操作系统

#### 注意

- 多道

	指内存中可同时存放的程序的个数。

- 多任务操作系统指具备任务并发性的操作系统。

### 操作系统环境

- CPU 的状态

	- 核心态（也叫管态，内核态）
		- 在核心态下，CPU 可执行指令系统中的任何指令。
	- 用户态（也叫目态）
	- 状态转换 王道P22.9
		- 核心态到用户态：由操作系统程序操作。
		- 用户态到核心态：由**硬件中断机制**操作。
		- 注意
			- 核心态程序只有在核心态中才能执行，无法完成从用户态到核心态的状态转换。
			- **中断处理程序**属于核心态**程序**，也无法完成从用户态到核心态的状态转换。

- 内核主要包括

	- 时钟管理

		对硬件时钟的管理，而不是对软件时钟的管理。

	- 中断机制

		中断机制中只有一小部分属于内核，负责保护和恢复中断现场，转移控制权到相关处理程序。

	- 原语

		定义原语的直接方法是关闭中断，原语执行完后再打开中断。

	- 系统控制的数据结构及处理

		- 进程管理
		- 存储器管理
		- 设备管理

- 中断和异常

	- 发生中断或异常时，CPU 会立即进入核心态（通过硬件实现）。
	- 中断（有时也叫外中断）
		- 内中断（也叫**异常**，陷入）
			- 自愿中断——指令中断
			- 强迫中断——硬件故障、**软件中断**
		- 外中断（强迫中断）
			- 外设请求（设备请求引起的中断）
			- 人为干预
	- 杂项
		- 使用系统服务时，通过**中断机制**进入核心态。
		- 出现异常情况时，通过**异常处理**进入核心态。
		- 从用户态转入核心态的唯一途径是中断或异常。
		- 有些异常可以经过异常处理恢复，从而继续运行，但有些无法恢复，只能终止程序。
		- 缺页属于异常。
	

### 操作系统的体系结构

- 微内核

	- 最基本的功能保留在内核。

	- 客户\服务器模式。

	- 优点

		有效分离了内核与服务，服务与服务，使得它们间的接口更加清晰，使系统更加可靠，便于升级维护，便于扩展。

	- 缺点

		需要频繁在内核态和用户态切换，操作系统的执行开销大。

## 进程管理

### 进程与线程

- 进程映像（实体）由程序段、相关数据段和 PCB 三部分组成。

- 进程映像是静态的，进程是动态的。

- PCB 是进程存在的唯一标志。

- 进程状态

  - 运行态
  - 就绪态
  - 阻塞态
  - 创建态
  - 结束态

- 在抢占式系统中，有更高优先级的进程就绪时，系统就将正在运行的程序转为就绪态。

- 进程从运行态到阻塞态是主动行为，从阻塞态到就绪态是被动行为。

- 系统使用 创建、撤销（终止）、阻塞、唤醒 等原语控制进程。

- 子进程可以继承父进程的资源。

- 子进程被撤销时，应当归还资源。

- 撤销父进程时，必须同时撤销所有子进程的资源。

- 进程调度与处理机模式切换（核心态，用户态）的区别：

  - 模式切换无需改变当前进程的环境信息。
  - 进程调度要改变当前进程的环境信息。

- 切换和调度的区别

  - 资源调度是决策行为。
  - 进程切换是执行行为。
  - 先决策再执行。

- 操作系统通过 **PCB 表**来管理和控制进程。

  - PCB 的组织方式

  	- 链接方式

  		链接成一个队列，不同状态对应不同队列。

  	- 索引方式

  		不同状态对应不同的索引表。

- 程序可被多个进程共享，即多个进程可以运行同一个程序。

- 进程通信

  - 低级通信方式

  	- PV 操作

  - 高级通信方式

  	- 共享存储

  	  - 基于数据结构的共享
  	  - 基于存储区的共享
  	  - 两个进程共享空间，必须通过系统调用实现。
  	  - 同一进程内的线程自然共享进程的空间。
  	
  	- 消息传递
  	
  		- 发送消息（这是原语的名字）
  	
  		- 接收消息（这是原语的名字）
  	
  		- 直接通信方式
  	
  			将消息发送到另一个进程的消息队列上，以供其取出。
  	
  		- 间接通信方式
  	
  			从中间实体（一般为信箱）取得消息。
  	
  	- 管道
  	
  		- 管道是连接一个写进程和一个读进程的共享文件。
  		- 管道是一个**固定大小**的缓冲区。
  		- 从管道读数据是一次性操作，一但读取，就被清空，以便接收新的数据。
  		- 管道只能半双工通信，某一时刻只能单向传输，要实现互动通信，需要定义两个管道。
  		- 缓冲区空时才开始写数据，缓冲区满时才开始读数据。（除非手动刷新）
  		- 一个管道可以实现**双向**的数据传输，但**同一时刻**只能单向传输。
  		- 注意区分**管道**和 **I/O 通道**。

- 线程

  - 线程与同属一个进程的所有线程共享进程资源。
  - 线程状态
  	- 就绪
  	- 阻塞
  	- 运行
  - 线程实现方式
  	- 用户级线程
  		- 线程管理由用户程序完成，内核意识不到线程的存在。
  	- 内核级线程
  		- 线程管理由内核完成，用户程序只有一个连接到内核线程的编程接口。
  	- 连接方式
  		- 一对一
  		- 多对一
  		- 多对多

- 进程与线程

	- 进程作为除 CPU 外的资源的分配单位，线程作为处理机（CPU）的分配单位。
	- 进程是**资源拥有**、**资源分配**的基本单位，线程是独立调度的基本单位。
	- 引入线程后，线程是**资源调度和分派**的基本单位。

- 杂项

	- 同一个系统的进程或线程可以由系统调用的方法被不同的线程或进程多次使用。
	- 若其余进程都阻塞，则当前运行进程继续运行，不会变成就绪态。
	- 父进程可与子进程共享一部分资源，但系统会为两个进程都分配空间，它们的地址空间不是共享的。
	- 当系统中既没有运行进程，也没有就绪进程时，可能其余进程都处于等待态，或死锁状态。
	- 正在运行的进程不一定是优先级最高的，高优先级进程可能正处于阻塞态。

### 处理机调度

- 调度层次

  - 作业调度（高级调度）
  	- 内存与辅存之间的调度。
  	- 每个作业只调入一次、调出一次。
  	- 多道批处理系统使用。
  - 内存调度（中级调度）
  	- 挂起态
  - 进程调度（低级调度）
  	- 操作系统最基本的调度。
  	- 操作系统都要配置进程调度。
  - 注意
    - 作业调入，和进程调度的时间可以忽略不计，但进程执行需要一定的时间，作业执行就是其进程执行，以进程执行计算时间。王道 P72.7

- 调度时机

	- 不能调度的时机
		- 进程处于中断处理中。
		- 进程在操作系统**内核程序**临界区中。若是用户程序临界区则可以，比如访问打印机时。 王道P69.28
		- 需要完全屏蔽中断的原子操作过程中。

- 调度方式

	- 非剥夺调度方式（非抢占方式）

		适用于批处理系统，不能用于分时系统和大多数实时系统。

	- 剥夺调度方式（抢占方式）

		剥夺要遵循一定的规则，如优先权，**时间片**等。

- 调度的衡量指标

  - CPU 利用率

  - 系统吞吐量

  	单位时间内 CPU 完成的作业数量。

  - 周转时间

    作业提交到作业完成经历的时间。

    - 平均周转时间

    	多个周转时间的平均值。

    - 带权周转时间

    	作业周转时间与作业实际运行时间的比值。

    - 平均带权周转时间

    	多个带权周转时间的平均值。
    	
    - 注意每个进程提交时间和终止时间运算。

  - 等待时间

  	进程处于**等待处理机状态**的时间之和。

  - 响应时间

  	用户提交请求到系统首次响应所用的时间。

- **调度算法**

	- 先来先服务（FCFS）
		- 用于作业调度，进程调度。
		- 属于不可剥夺算法。
		- 不能作为分时系统和实时系统的主要策略，往往结合在其它算法中。
		- 对长作业有利，对短作业不利。
		- 有利于 CPU 繁忙型，不利于 I/O 繁忙型。
	- 短作业优先 SJF，短进程优先 SPF
		- 用于作业调度，进程调度。
		- 选择剩余运行时间最短的进程分配给 CPU 。
			- 这个剩余运行时间只在进程调入时比较一次，不是动态比较的，要等短进程先执行完才能切换。 王道P74.12
		- 饥饿现象（长作业长期不被调度）
		- SJF、SPF 的平均等待时间和平均周转时间最少。
		- 抢占式
		- 非抢占式
	- 优先级调度算法
		- 用于作业调度，进程调度。
		- 抢占式
		- 非抢占式
		- 静态优先级
		- 动态优先级
	- 高响应比优先调度算法
		- 用于作业调度。
		- 将响应比最高的作业分配给处理机。
		- 响应比 $R_p = {等待时间 + 要求服务时间 \over 要求服务时间} $ 。
			- 有利于短作业
			- 长作业等待时间足够长也可获得处理机。克服了饥饿现象。
	- 时间片轮转调度算法
		- 适用于分时系统。
		- 适用于进程调度。
		- 轮转调度时要注意就绪队列进程的顺序。王道P64.8
			- 进程 $A$ 正在时间片内运行，这时一个进程 $B$ 加入就绪队列，则 $A$ 的时间片结束后，其在就绪队列中的顺序在 $B$ 之后。特别是时间片单位不是一个单位时，尤其要注意这种情况。
		- 轮转模拟较复杂，最好一个单位一个单位模拟。
		- 模拟方法 王道P73
			- 一个进程编号代表一个单位时间。
			- 记录各进程的时间余量。
			- 记录就绪队列，以按正确顺序（FCFS）分配时间片。
			- 记录进程终止时间。
		- 时间片轮转调度算法是绝对可抢占的算法，由时钟中断产生。 王道P73.9
			- 操作系统每秒产生一定数量的中断，在这些中断之间，程序可以运行。
			- 每个时间片占有一定数量的中断间隔，
	- 多级反馈队列调度算法
		- 多个就绪队列，拥有不同优先级。
		- 优先级越高的队列时间片越小。
		- 优先级最低的队列采用时间片轮转调度算法。
		- 优先级高的队列所有进程运行完毕，或要么运行完毕，要么处于等待态，就执行下一优先级队列的进程。
	- 注意
		- 时间片轮转是绝对可抢占的（时间片到），而优先级算法和短进程优先算法都分为抢占式和非抢占式。
		- 短进程优先的抢占式是比较的进程需要的剩余运行时间（只在调入新的进程时比较一次，不是动态比较的）。 王道P64.12
		- 当进程调度和作业调度的时间冲突时，先考虑作业调度，再考虑进程调度。 王道P74.12
		- 注意作业调度中能够同时调入内存的作业数限制（道数）。
	- 优先级的设置
		- 系统进程高于用户进程
		- 交互型进程高于非交互进程
		- I/O 型进程高于计算型进程。

### 进程同步

- 临界资源

	- 进入区

	- 临界区（又称临界段）

		访问临界资源的那段代码。

	- 退出区

	- 剩余区

- 同步（直接制约关系）

	执行顺序的关系。

- 互斥（间接制约关系）

  互斥访问的关系。

- 能否正确运行

  - 当若干进程按不同代码顺序得到的执行结果不同，则是不能正确运行。

- 输出种类

  - 分析变量制约关系
  - 考虑插空法

- 同步机制

  - 控制进程同步与互斥关系的机制。
  - 为满足互斥条件，四条准则
  	- 空闲让进
  	- 忙则等待
  	- 有限等待
  	- 让权等待（这一个不一定非得实现）

- 实现临界区互斥的基本方法

  - 软件实现方法

  - 硬件实现方法（低级方法，元方法）

  	- 中断屏蔽方法

  	- 硬件指令方法

  		硬件指令由硬件实现，不会被中断。

- 信号量

  - 基于两个原语
  	- P 操作，又称 wait(S)
  	- V 操作，又称 signal(S)
  	- 原语不被中断的特性是由屏蔽中断实现的。
  	- P、V 操作是低级进程通信原语。
  	- P、V 操作必须成对存在。
  	
  - 实现前驱关系 王道P81
  	- 对前驱图的若干边设置信号量。
  	
  - 实现互斥关系
  	- 设置资源信号量。
  	
  - 信号量的初值是由用户根据需要设定的。

  - 互斥信号量

  	互斥信号量的初值一定为 $1$ 。互斥使用某一资源，代表某一时间最多只能有一个进程使用资源。

  - 资源信号量

- 管程

  - 出现原因：大量分散的同步操作给系统管理和维护带来了麻烦，且容易因操作不当导致死锁。
  - 三部分组成
  	- 管程的共享变量说明。
  	- 该数据结构的一组操作过程。
  	- 初始化语句，另外，管程还有一个名字（标识符）。
  - 管程把对共享资源的操作封装起来。
  - 每次只允许一个进程进入管程。
  - 条件变量
    - 每个阻塞原因建立一个条件变量，对应一个阻塞队列。
  - 管程既可以实现进程互斥，也可以实现进程同步。
  - 若一个进程使用了管程的 ```x.wait()```，则其将自己阻塞到条件 x 的阻塞队列上，让出管程控制权。

- 经典同步问题

  - 生产者消费者问题
  	- 缓冲区空才能放入。
  	- 缓冲区满才能取出。
  - 读者写者问题
  	- 可同时读（允许多个读者同时读），不能同时写。
  	- 不能同时读写。
  - 哲学家进餐问题
  	- 解决的三种方法
  		- 至多允许 $n-1$ 名哲学家同时进餐。即至少剩下一只筷子，至少有一个哲学家能够拿到两只筷子。实际上，由于筷子数量的限制，同时进餐的哲学家远远达不到 $n-1$ 。
  		- 仅当一名哲学家左右筷子都可用时，才允许拿起筷子，且一下拿起两根。
  		- 对哲学家编号，奇数号先拿左边，偶数号先拿右边。（也可反过来）

- 重要杂项

  - 信号量值的意义
  	- 正值表示剩余资源数。
  	- 为 $0$ 表示剩余资源数为 $0$，且有若干个进程处于临界区，没有进程等待。
  	- 负值表示处于等待资源状态的进程数，且有若干个进程处于临界区。
  - 区分
    - V 操作和**管程的** Signal 不同，V 操作一定会改变信号量的值，而 Signal 是针对某个条件变量的，若该条件变量没有对应的阻塞进程，则 Signal 不会产生任何影响。 王道P104.30
  - 对于给出进程代码判断运行情况的题，考虑可能会出现多个相同的进程。 王道P132.22
  - 进程运行的结果的种类数，要考虑所有变量的改变。王道P132.23

- **PV 操作问题**

  - 互斥信号量 mutex

  	- 只要有共享访问的资源（物体，事件），就要考虑是否互斥。
  	- 只有一个进程访问的共享资源不设置互斥，必须要多个进程共同访问的资源才设置互斥。王道 P101.23
  
  - 前驱顺序信号量 e12，e23，初值为 $0$ 
  
  - 计数信号量 count，n
  
    - 对于计数行为，可考虑用资源信号量或单独的计数变量操作，但后者需要设置信号量以保证计数变量的互斥访问。
    - 空间计数
    	- 空位量计数 bucket，cell，empty
    	- 存在量计数 exist，full
    	- 空位量和存在量往往要协作。
    - 单纯数量计数
    	- 计数信号量的值是否为 $0$（或 $1$）可以判断是第一个还是最后一个，亦可判断是第几个或倒数第几个。王道P98.13
  
  - 标记信号量 flag，tag，state
  
    标记某一事件或状态。
  
  - 资源信号量
  
    - 一次访问多个资源时，可连续对该资源信号量用多个 PV 操作。
    - 某个事物可能有数量上限，使用资源信号量时要注意。王道P99.15
  
  - 除了信号量相关的语句，还可以加上流程控制，数值计算等一般代码语句。
  
  - 信号量天生能够保证进程互斥访问信号量本身。
  
  - 一般先访问剩余容量变量，有剩余容量后再互斥访问容器。
  
  - 不会写的英文可直接写成中文。
  
  - 排队
  
    - 可设置一个排队信号量 queue，代表阻塞队列，进程 ```P(queue)``` 后在阻塞队列中排队。 王道P98.12
  
  - 有时可以用操作语句访问信号量的值，即将其当作一般的整型变量使用。
  
  - 可以为引起阻塞的事件（原因）设置信号量，从而达到阻塞进程的目的。 王道P99.17

### 死锁

- 产生原因

	- 对不可剥夺资源的竞争。
	- 请求和释放资源顺序不当。
	- 信号量使用不当，进程互相等待对方发来消息。

- 死锁产生的必要条件

	以下四个条件必须要同时满足才会产生死锁。

	- 互斥
	- 不剥夺（资源只能由进程主动释放）
	- 请求并保持
	- 循环等待（这里不是指“死等”，是指成环形的请求）

- 死锁的处理策略 王道P123

	- 死锁预防

		破坏若干个必要条件。

		- 破坏互斥
			- 不现实，有些资源一定是互斥资源，而且有些场合应该保护互斥性。
		- 破坏不剥夺
			- 已拥有一部分资源的进程请求新进程是失败时必须释放已拥有资源。
			- 释放已拥有资源可能导致前一段工作实效，反复释放申请增加了系统开销。
		- 破坏请求并保持
			- 只允许运行前一次申请完所有资源，否则不予运行。
			- 资源被严重浪费，有些资源使用的时间量很少。
			- 饥饿现象，个别资源长期被其它进程占用，导致其它进程一直得不到运行。
		- 破坏循环等待
			- 给系统中的资源编号，进程只能按编号递增的顺序请求资源，同类资源一次申请完。
			- 限制了新设备的增加。
			- 使用资源的顺序不灵活，降低系统效率。
			- 给用户编程带来麻烦。

	- 死锁避免

	  防止系统进入不安全状态。

	  - 不安全状态

	  	在每次分配资源前，计算安全性，若无法找到一个安全序列，则称系统处于不安全状态。

	  - 银行家算法 操作系统P120 王道P126

	  	- 所用数据结构

	  		- 可用资源向量 Available
	  		- 最大需求矩阵 Max
	  		- 分配矩阵 Allocation
	  		- 需求矩阵 Need $Need = Max - Allocation$

	  	- 流程

	  		请求向量 Request

	  		- 对比 Request 和 Need

	  			判断申请资源数是否合法。

	  		- 对比 Request 和 Available

	  			判断资源是否足够。

	  		- 试探分配

	  			对各矩阵变换状态。

	  		- 执行**安全性算法**

	  			若安全则分配资源，若不安全则让该进程等待并恢复数据结构状态。
	  			
	  			要点如下：
	  			
	  			- 得到 Need，Allocation，Max，Available
	  			
	  			- 初始化 Work = Available
	  			
	  			- 比对 Work 和 Need，不断分配，增加 Work 。
	  			
	  				Work = Work + Allocation
	  			
	  				实际上 Work 就相当于预测路线中某一时刻的可分配资源数量。
	  			
	  				也可直接比较 Available，不断增加 Available 即可。
	  			
	  			- 注意只有一种资源时矩阵的写法。
	
	- 死锁检测及解除
	
	  - 资源分配图
	  	- 圆圈代表进程
	  	- 矩形代表资源
	  	- 请求边
	  	- 分配边
	  	- 具体操作 王道P134.31
	  		- 画出资源分配图（请求边，分配边）
	  		- 找是否是死锁状态
	  			- 对分配图化简。
	  		- 找最少死锁进程个数
	  			- 化简，减少进程。
	  			- 改请求为分配，构造最小环。
	  		- 找最多死锁进程个数
	  			- 改请求为分配，构造最大环。
	  			- 注意减去必不可能处于死锁状态的进程。
	  - 死锁定理
	  	- 当且仅当资源简化图不可完全简化时，为死锁状态。（死锁定理）
	  	- 简化资源分配图 王道P129
	  		- 找出有空闲资源也不孤点的进程。（能够被满足的进程）
	  		- 消去它的所有请求边和分配边，使之称为孤点。
	  - 死锁解除
	  	- 资源剥夺法
	  	- 撤销进程法
	  	- 进程回退法
	
	- 杂项
	
		- 对**独占资源**的分配不当，对互斥资源的部分分配且不可剥夺，极易造成死锁。
		- 系统资源不足只会对进程造成饥饿，不是死锁的原因，系统资源不足不等于剩余资源不足。
		- 只有当某个进程提出资源请求，导致两个或两个以上进程进入阻塞态时，系统才处于死锁状态。
		- 饥饿和死锁的区别
			- 进入饥饿状态的进程可以只有一个，而因循环等待条件进入死锁状态的进程必须两个及以上。
			- 处于饥饿状态的进程可以是就绪进程（如一个低优先权进程），而死锁状态的进程都是阻塞进程。

## 内存管理

### 基本概念

- 程序装入与链接

  - 编译

    将源文件编译为目标模块。

    - **目标模块的逻辑地址**（相对地址）。

  - 链接

    将目标模块与**库函数**链接在一起，形成装入模块。

    - 链接阶段主要完成重定位，形成**整个程序的逻辑地址**。 王道P171.1

    - 而装入阶段是完成程序逻辑地址到**物理地址**的转换。

    - 有三种方式：

      - 静态链接

      	链接为完整程序，不再拆开。
      	
      - 装入时动态链接

        装入内存时，一边装入一边链接。

        - 动态链接与逻辑划分有关，分段式有利于动态链接。

      - 运行时动态链接

        程序运行时，需要该模块时才链接。

  - 装入

    由装入程序将装入模块装入内存运行。

    完成程序逻辑地址到**物理地址**的转换。

    有三种方式：

    - 绝对装入

    	固定的内存位置，只适合单道程序环境。

    - 可重定位装入（静态**重定位**）
    
    	- 装入时一次完成重定位。
    	- 先分配足够的内存才能静态重定位，一旦进入内存，整个运行期间不能在内存中移动，也不能申请新的空间。

    - 动态运行时装入（动态**重定位**）
    
    	- 需要重定位寄存器。
    	- 可以将程序分配到不连续的存储区中。
    	- 可以只装入部分代码就运行。
    	- 可根据需要动态申请内存。

- 地址空间

	-  逻辑地址空间

		目标模块的相对地址（或逻辑地址）（即程序模块的逻辑地址）

	-  物理地址空间

		内存单元中的地址空间。

		- 地址重定位

			装入内存时，必须通过地址转换，将**程序的**逻辑地址空间转换为物理地址空间。

- 内存保护

    - 目的

      - 保护操作系统不受用户进程影响。
      - 保护用户进程不受其它用户进程影响。
      - 多进程通过内存保护实现互不干扰。

    - 手段

    	- 在 CPU 中设置上下限寄存器。

    	- 设置两个寄存器

    		- 重定位寄存器（基址寄存器）

    			含**物理地址**最小值。（提供开始位置）

    		- 界地址寄存器（限长寄存器）

    			含**逻辑地址**最大值。（比较结束位置）

- 多道环境下扩充内存的两种方法

  覆盖和交换解决主存空间不足的问题，节约主存空间。

  - 覆盖

  	针对同一个程序（或进程）。

  	- 将用户程序空间分为固定区和若干覆盖区。
  	- 程序活跃的部分放在固定区。
  	- 外存中不活跃的部分需要的时候调到覆盖区使用，覆盖原有的数据。

  - 交换

    针对不同进程（或作业）

    - 换出

      将处于等待状态（或其它被剥夺运行权利的状态）的程序移至外存。

    - 换入

      把其它程序移入内存。
    
  - 覆盖与交换可以实现一定程度上的虚拟存储。

### 连续分配管理方式

- 单一连续分配

	- 系统区

		操作系统使用。

	- 用户区

		用户程序使用，内存中只允许有一道程序。

	- 只适用于单用户、单任务的操作系统。

	- 有内部碎片。

- 固定分区分配

  - 划分为若干分区，每个分区装入一道作业。

  - 分类

    - 分区大小相等

      控制多个相同对象。

    - 分区大小不等（固定分区的分区大小可以不等）

      将分区按大小排队，建立**分区说明表**，说明分区始址、大小及状态（是否已分配）。

  - 程序太大无法放入一个分区时，要使用覆盖技术。

  - 程序小于分区大小时，也占用一个分区，有内部碎片。

  - 固定分区的大小是不变的，分区大小不等时，对**各个大小的固定分区**有若干个，可能产生内部碎片。

  - 固定分配页面数不变。

- 动态分区分配（可变分区分配）

	- 存在外部碎片。

	- 每隔一段时间需要进行紧凑。

	- 分配策略

		- 首次适应算法（最简单，通常也最好、最快）

			空闲分区以**地址递增**次序链接，顺序查找第一个空闲分区。

		- 最佳适应算法

			**容量递增**次序链接，找到第一个能满足要求的空闲分区。

		- 最坏适应算法（最大适应算法）

			**容量递减**次序链接，找到第一能满足要求的分区（第一个最大分区）。

		- 邻近适应算法（首次循环适应算法）

			在首次适应的基础上，从上次查找结束位置开始本次查找。

		- 对比 王道P154
	
- 回收空闲分区时采用**拼接**技术，合并空闲区。

### 非连续管理方式

- 因为需要额外存储索引的空间，所以非连续方式比连续方式存储密度低。

#### 基本分页存储管理方式

- 主存空间以块为单位，不会产生外部碎片，内部碎片（页内碎片）非常少。

- 基本概念

  - 进程中的块称为页
  - 内存中的块称为页框（页帧）
  - 外存同样单位，也称为块。
  - 叶故障就是缺页。

- 页表

  - 系统为每个进程建立一张页表，一般存放在内存中。
  - 实现页号到物理块号的地址映射。
  - 注意，页表存放在内存中，页表始址存放在一组寄存器中。

- 基本地址变换机构

	- 由硬件自动完成

	- 页表寄存器

		​	存放页表始址和页表长度。

	- 页表长度

		指一共有多少页。

	- 页表项长度

		指出页地址占多大的存储空间。

	- 页式管理的地址空间是一维的。

- 具有快表（相联存储器，TLB）的地址变换机构

	- 局部性原理。
	- 页表又称慢表。
	- 在读出页表项后，要将其存入快表。（在请求分页管理中，若缺页，调入新页面时，也会顺便写入快表）
	- 若快表已满，要进行替换。

- 两级页表

	- **顶级页表最多只能有一个页面。**
	- 一级页号，二级页号，页内偏移。
	- 页目录号，页号，页内偏移。
	- 二级页表，每一页会在顶级页表中有一个页目录项。
	- 多级页表是为了减少页表所占的**连续**存储空间。

#### 基本分段存储管理方式

- 段内要求连续，段间不要求连续，作业的地址空间是二维的。

- 为了满足用户的以下要求：方便编程，分段共享，分段保护，**动态链接和动态增长**。

- 段表

  段号，段长，本段在主存的始址。

- 一个进程只有一张段表，段表项的数量要通过段内偏移计算。 王道P210.5

- 地址变换机构

	- 段表寄存器，存放段表始址和段表长度。

- 段的共享与保护

	- 段的共享通过在两个作业的段表的相应表项中指向被共享的段实现。
	- 段内偏移可能越界，但页内偏移不可能越界，因为页内偏移是固定宽度，而页面大小也是固定的。

#### 段页式管理方式

- 分段，段内再分页。
- 每个进程一个段表，每个段一个页表（段有多个）。
- 段页式管理的地址空间是二维的。

#### 碎片

- 固定
	- 固定分区只有内部碎片。
	- 分页式只有内部碎片。
	- 段页式只有内部碎片。
- 不固定
	- 分段式只有外部碎片。
	- 各动态分区分配算法都只会产生外部碎片。（动态分区分配）
- 注意题目说的是**内部**碎片还是**内存**碎片（内存碎片包括内部碎片和外部碎片）。

### 虚拟内存管理

#### 基本概念

- 利用程序局部性，属于高速缓存技术。
	- 时间局部性
	- 空间局部性
- 虚拟存储的特性
	- 多次性
	- 对换性
	- 虚拟性
- 虚拟技术需要建立在离散分配的内存管理方式上（分页，分段，段页）。
- 实现方式
	- 请求分页存储管理
	- 请求分段存储管理
	- 请求段页式存储管理
- 需要硬件支持
	- 内存和外存
	- 页表机制（或段表机制）
	- 中断机构
	- 地址变换机构（逻辑地址到物理地址的变换）
- 注意
  - 缺页时以**页**在不在**内存**为依据，而不是以**页号**在不在**页表**为依据。
  - 执行的程序，其**所需的所有页的页号都在页表中**，页表在内存，页号在页表中（页号一定在内存），但页不一定在内存。王道P194.5
  - 有效访问时间即平均访问时间。

#### 请求分页方式

一般以请求分页为例。

- 页表机制

  在（请求）页表项增加四个字段

  - 状态位 $P$

  	指示该页是否已调入内存。

  - 访问字段 $A$

  - 修改位 $M$

  - 外存地址

  	外存上的物理块号。

- 缺页中断机构

  - 所要访问的页面不在内存中时，产生缺页中断（缺页异常，页故障）。
  - 缺页进程被阻塞，调页后唤醒。
  - 缺页中断与一般中断的区别
  	- 缺页中断在**指令执行期间**产生和处理中断，属于**内部中断**。
  	- 一条指令在执行期间可能产生多次缺页中断。
  - 若缺页，调入新页面时，会顺便写入快表。 王道P207
  - 缺页调入新页面后，仍然会先访问快表。王道P208.5

- 地址变换机构 王道P184

#### 页面置换算法

- 最佳置换算法（OPT）

	- 淘汰**最长时间内不会再访问**的页面。
	- 该算法无法实现，常用来评价其它算法。

- 先进先出置换算法（FIFO）

  选择最先**进入内存**的页面。

  - Belady 异常（只有 FIFO 可能出现 Belady 异常）

  	随着所分配的物理块的增多，缺页数不减反增的异常现象。

  - FIFO 基于队列实现。

- 最近最久未使用置换算法（LRU）

  - 淘汰最近一段时间，最久**未访问过**的页面。
  - 需要寄存器和栈的硬件支持。
  - 属于堆栈类算法（堆栈类算法不可能出现 Belady 异常）
  - LRU 的性能接近 OPT，但开销大。
  - 模拟方法 王道P204
  - 实现起来耗费高，因为要对访问过的页面的访问时间排序。

- 时钟置换算法（CLOCK） 王道P187

	循环检查各页面情况。
	
	- 简单 CLOCK 算法（最近未用算法（NRU））
		- 为帧添加**访问位**
	- 改进型 CLOCK 算法
		- 为帧添加**访问位**和**修改位**
		- 原理
			- 访问位，修改位 $(x,y)$
			- 选择优先顺序：$(0,0),(0,1),(1,0),(1,1)$
				- 未访问过且未修改过最优先。
				- 未访问过优先（修改过虽然要写回内存，但访问过的可能会再次访问）
				- 既访问过又修改过最后。
	
- 注意

	- 置换页面时，若原页面在 $x$ 号页框，则置换进来的新页面就是在 $x$ 号页框。
	- 若有未访问过且未修改的页面，不必调出，直接调入新页占用其页框；
	- 若页面被修改过，则要写回外存，先调出，再调入。
	- 只要没有修改过，就可以不调出，直接调入新页占用其页框。
	- 只有 FIFO 有 Belady 异常，但所有页面置换算法都可能抖动。
	- 置换时，选择页表中的一项淘汰。 王道P208.5

#### 页面分配策略

- 驻留集

	给一个进程分配的物理页框的集合。限定了页表中有效页表项的数量。

	- 如果页数过多，给某进程分配更多的内存空间对其错误率没有明显的效果。

- 置换策略 王道P189

  注意，这里的固定和可变是指对程序包含的物理块的分配，不是静态和动态的分区分配。

  - 固定分配局部置换

  	- 进程被分配的物理块数是固定的，在运行期间不改变。
  	- 发生缺页时，只能从本进程的页面中选择调出。

  - 可变分配全局置换

  	- 系统维护一个空闲物理块队列。

  - 可变分配局部置换

  	- 发生缺页时，只能从本进程的页面中选择调出。
  	- 但当缺页率高时，系统再分配给其物理块。
  	- 当缺页率特别低时，系统适当减少给其物理块。

  - 区分

  	- 局部置换

  		发生缺页时，只能选择进程自身的页面换出。

  	- 全局置换

  		发生缺页时，可以从其它进程的页面中选择调出，然后把空闲物理块分配给当前进程。（全局置换不可能是固定分配）

- 调入时机

	一般两种策略同时使用。

	- 预调页策略

		运行前预测调入。

	- 请求调页策略

		运行中调入。

- 从何处调入 王道P189

	- 文件区
	- 对换区

- 抖动（颠簸）

	换页时间相比执行时间过多。

- 工作集 王道P190

	某段时间内**可能将要**访问的页面的集合。基于局部性原理，工作集**近似等于**最近已访问过的页面集合。

	- 局部性好的程序工作集较小。
	- 若分配的物理块数小于工作集，那么很可能会频繁缺页。
	- 一般分配给进程的物理块数（即**驻留集**大小）要大于**工作集**。
	- 注意
		- 指定一个**工作集窗口大小**，
		- 工作集是个集合，是对**工作集窗口**内的页面去重后的集合
		- 工作集的大小一定小于等于工作集窗口的大小。

#### 虚拟存储容量界限

- **实际**最大容量 小于等于 内存容量和外存容量之和。
- **理论**最大容量 小于等于 计算机地址位数能容纳的最大容量。
- 实际应用时，要取两个条件的交集，即共同满足两个条件。
- 如果题目只说最大容量，没说实际容量，那么以理论容量为准。 王道P194.13

## 文件管理

### 基本概念

王道P216

- 所有文件信息都保存在文件目录中，文件目录保存在外存上。

- 文件目录也就是**目录文件**的内容。

- 打开与关闭

	- 打开文件表

	  操作系统维护的一个包含所有打开文件的表。

	- 文件打开计数器

	- 文件控制块（FCB）
	
	- 文件描述符（文件句柄）
	
		- 打开文件（open）会返回一个**文件描述符**（Unix），以后不必使用文件名，只需使用文件描述符。Windows 称为**文件句柄**。
	
	- 文件指针
	
	  系统跟踪上次读写位置作为当前文件位置的指针。
	
	- 多个进程可以同时以“读”或“写”方式**打开**文件，只是在具体使用时要保证互斥。
	
	- 打开文件后，文件目录被调入内存。

#### 文件的逻辑结构

- 无结构文件（流式文件）

	以字节（Byte）为单位。

- 有结构文件（记录式文件）

	- 顺序文件
		- 文件通常是定长的。
		- 可顺序存储或链表存储。
		- 只有顺序文件能存储在磁带上。
	- 索引文件
		- 对于变长文件，无法随机访问，顺序查找开销较大。
		- 建立一张索引表，索引表本身是可随机访问的定长记录文件。
	- 索引顺序文件
		- 将顺序文件的所有记录分成若干组，为顺序文件建立一张**索引表**。
		- 同一个组中的关键字可以无序，但组与组之间关键字必须有序。
		- 首先通过索引表查找所在的组，然后在组内顺序查找。
		- 对于 $N$ 条记录，分为 $\sqrt{N}$ 组，每组 $\sqrt{N}$ 个记录，此时查找效率最大化，平均查找 $\sqrt{N}$ 次。
	- 直接文件（散列文件）
		- 哈希查找
	- 注意
	  - 文件的**逻辑索引**（逻辑索引表）的目的是加快文件数据的定位，是从用户角度出发的。
	  - 文件的**物理索引**（物理索引表）的目的是管理不连续的物理块，是从系统管理的角度出发的。

#### 目录结构

目录结构即文件与文件之间的组织结构。

- 数据结构

  - 文件控制块（FCB）
  	- 保存文件名，文件物理地址等文件信息。
  	- FCB 的有序集合称为**文件目录**，一个 FCB 就是一个文件目录项。
  	- **目录文件**存放的是子目录和数据文件的信息。
  	- 文件名和文件描述信息不分离 （Windows）（也可分离，依具体题目而定）
  		- 文件的文件名和文件描述信息都是放在 **FCB** 中的。
  	
  - 索引结点
  	- 存放文件描述信息
  	
  		包括文件的物理地址等信息。
  	
  	- 简称 $i$ 结点。
  	
  	- 在检索目录时，文件的其它描述信息不会用到，也不需要调入内存。
  	
  	- 注意，索引结点的“索引”是该类结点的名字，不是指结点类型（与索引文件区分）。
  	
  	- 文件名与描述信息分离（UNIX）
  	
  		- 使用**索引结点**存放文件描述信息。
  		- 文件名在文件目录中。
  		- **文件目录**中的每个目录项由**文件名**和**指向索引结点（i 结点）的指针**构成。
  	
  - 磁盘索引结点（UNIX）
  	- 就是存放在磁盘上的文件**索引结点**。
  	- 包含文件物理地址等信息。
  	- 文件被打开时，磁盘索引结点被复制到内存中，以便于使用。
  	- 磁盘中的索引结点在一个索引结点表中。
  	
  - **注意**

    - 每个文件都有一个 FCB（Windows） 或 索引结点（Unix）。

    - 对于不同分配方式的文件，所含信息的差异（注意，**该信息可能因题目所给文件系统不同而存在差异，以具体题目条件为准。**）

      - 对于 FCB
        - 连续文件在 FCB 中的信息为：首块地址，块总数。
        - 链接文件
          - 隐式链接：首块地址，尾块地址
          - 显示链接：首块地址（起始块号，可以作为开始查找 FAT 的下标）（后续的块需要去查系统的 FAT 表，FAT 表整个系统只有一张）
        - 索引文件：
          - FCB 中存放索引表地址或索引地址区（索引地址区内可能是混合地址项）。
      - 对于索引结点
        - 索引文件：一般 13 个混合地址项

    - 文件目录与目录文件

      - 文件目录

        - Windows

          把多个 FCB 组织在一起。（FCB 就是文件目录项）

          - 注意，有时候题目所给是文件目录存储文件名和 **FCB 的物理地址**（而不是 FCB 本身）。 王道P246.7

        - Unix

          把多个（文件名与指向索引结点的指针）组织在一起。

      - 目录文件

        - 把文件目录当作文件保存，从用途上看是文件目录，从实现上看是目录文件。

- 目录结构

	- 单级目录结构

		文件不允许重名。

	- 两级目录结构

		- 将文件目录分为

			- 主文件目录（MFD）

				存放文件名和文件目录的存储位置。

			- 用户文件目录（UFD）

				存放文件 FCB 的信息。

		- 缺乏灵活性，不能对文件分类。

	- 多级目录结构（树形目录结构）

		- 在树形目录中查找一个结点时，需要按路径名逐级访问中间结点，增加了磁盘访问次数。
		- 便于文件分类，不便于共享。

	- 无环图目录结构（DAG 目录结构）

		- 引入共享边。
		- 每个结点设置一个共享计数器。
		- 便于共享。

- 文件共享

	- 静态共享方法
		- 硬链接
			- 相当于使用指针指向文件。（直接按指针读取，硬链接比软链接快）
			- 实际上指向文件的索引结点，索引结点有**链接计数变量**。
		- 软链接（符号链接）
			- 相当于存放了文件的路径。（按路径读取）
		- 共同问题
			- 当遍历整个文件系统时，硬链接和软链接都会导致多次遍历到该共享文件。
	- 动态共享方法
		- 两个进程同时对一个文件进行操作。

- 文件保护

	- 访问类型
		- 读
		- 写
		- 执行
		- 添加（追加）
		- 删除
		- 查看目录
	- 访问控制
		- 系统为每一个文件和目录增加一个**访问控制表**（ACL）。
		- 拥有者
		- 组成员
		- 其它人
	- 口令
		- 请求访问文件时必须提供口令。
		- 时间和空间开销少，但口令存放在系统内部，不够安全。
	- 密钥
		- 对文件进行加密，访问文件需要先用密钥解密。
		- 保密性强，节省空间，但编码和译码需要一定时间。

### 文件系统实现

#### 文件系统层次结构

王道P235

这节内容要多看书上的图。

#### 目录实现

- 注意

  - 读文件前必须打开文件。
  - 打开文件时，操作系统利用路径名找到相应目录项，**目录项提供了查找文件磁盘块（即文件物理地址）所需要的信息。**
  - 目录的存在就是为了便于文件查找。
  - 创建新文件时，必须首先查找，确定是否有同名文件存在。
- 线性列表

	- 线性查找
- 哈希表

	- 散列查找

#### 文件实现

- 文件的分配方式——对磁盘非空闲块的管理。
- 文件存储空间管理——对磁盘空闲块的管理。

##### 文件分配方式

- 连续分配
	- 每个文件在磁盘上占有一组连续的块。
	- 目录格式
		- 文件名
		- 第一块的磁盘地址
		- 连续块的数量
	- 这种排序使得作业访问磁盘时需要的寻道数和寻道时间最小。
	- 连续方式支持顺序访问和直接访问。
	- 优点是实现简单，存取速度快。
	- 缺点是文件长度不宜动态变化。
	- 会产生外部碎片。
	- 很难确定一个文件需要的空间大小，只适用于长度固定的文件。
	
- 链接分配
	- 隐式链接
		- 每个文件对应一个磁盘块构成的链表。
		- 除最后一个盘块外，每一个盘块都有指向下一个盘块的指针。
		- 目录格式
			- 文件名
			- 文件第一块的指针
			- 文件最后一块的指针
	- 显式链接
		- 设置**文件分配表（FAT）**
			- 文件分配表格式
				- 盘块号
					- 注意，FAT 可以支持直接访问，但准确访问较困难，因为 FAT 中文件的各个块不是按下标递增连续的，而是按链接号连续的。
				- 下一块盘块号
		- 目录格式
			- 文件名
			- 起始块号（对应到 FAT 的下标，从而能找到以后的盘块）
	- 离散分配，消除了外部碎片。
	- 可以动态地分配盘块。
	- FAT 表在系统启动时被加载入内存，也就是说，访问 FAT 表是在内存中访问。
	- 使用 FAT 读取某一个盘块时，虽然是链接方式，但是不必依次遍历磁盘块，只需依次遍历 FAT 表项，然后直接读取所需磁盘块。 王道P245.6
	
- 索引分配
	- 把文件的盘块号集中放在一起，构成**索引块（表）**。
	
	- 支持直接访问。
	
	- 索引块应尽可能小，但太小无法支持大文件，有以下解决措施：
	
	  - 链接方案
	
	  	将多个索引块链接起来。
	
	  - 多层索引（多级索引）
	
	  	- 注意，混合索引有各种级数的地址，但多层索引只有一种级数的地址。
	
	  - 混合索引
	
	    既采用直接地址，又采用多级索引。
	
	    - 直接地址
	    - 一级间接地址
	    	- 注意，一级目录和一级间接地址的访问层次是不一样的。
	    - 二级间接地址
	    - 三级间接地址
	
	- 通常将索引块读入内存中，以加快文件访问速度。
	
- 杂项

  - 注意各方式读取文件时访问磁盘次数。
  - 一个索引结点不一定占一个内存块，一个内存块可能含多个索引结点。
  - 碎片问题
  	- 连续分配：外部碎片
  	- 链接分配，索引分配：没有外部碎片。


##### 文件存储空间管理

王道P241

- 概念

	- 文件存储在文件卷中。
	- 文件卷分为目录区和文件区。
	- 文件存储空间管理是对空闲块的组织和管理。

- 空闲表法

	- 系统为外存的所有空闲区建立一张**空闲盘块表**。
	- 指明每个空闲区的第一个空闲盘块号，和空闲盘块数。

- 空闲链表法

	- 形式

		- 空闲盘块链

			以盘块为单位。

		- 空闲盘区链

			以盘区为单位。（一个盘区可包含若干盘块）

	- 从链首摘下分配。

	- 回收链接在链尾。

- 位示图法

  - 位示图默认行列下标从 $1$ 开始。
  - 行列下标转化为盘块号。
  - 盘块号转化为行列下标。
  - 编号对应
  	- 假定行列以 $1$ 开始，磁盘块号以 $1$ 开始。
  	- 计算并代换。（注意，代换时要考虑代换三个变量，$i,j,n$）

- 成组链接法（UNIX）

	- UNIX 中称为超级块。
	- 注意与混合索引区分。
	
- FAT 法

  - FAT 的表项与物理磁盘块一一对应，可以用特殊的数字表示文件末尾和空闲块，因此 FAT 表也可以用来管理空闲磁盘块。 王道P251.22

#### 注意事项

- **读**文件时，得到物理地址还要再 I/O 一次以读取该页或块。
- **读**文件时，若是索引方式，得到 **FCB 或索引结点**后，还要根据索引级数计算得到文件**某页物理地址**所需要的 I/O 次数。王道P252.7
- **读**文件时，得到文件**某页物理地址**后，才能开始读文件的页。
- **修改**文件时，读取文件后还要 I/O 一次以**写回**文件。
- 问读取最少次数和最多次数，要分别考虑文件的不同分配方式。

### 磁盘组织与管理

#### 磁盘结构

王道P256

- 磁盘地址用“柱面号，盘面号，扇区号（或块号）”表示。

#### 磁盘调度算法

- 一次磁盘读写的时间

  - 寻找时间 $T_s$

  	将磁头移动到指定磁道所需要的时间。取决于磁盘调度算法。

  	- 包括启动时间
  	- 跨越磁道时间

  - 旋转延迟时间 $T_r$

  	将磁头定位到某一扇区的时间。取决于旋转速度（线性相关）。

  	- 设 $r$ 为每秒转速。
  	- 则 $T_r = {1 \over 2r}$ （平均转半圈）

  - 传输时间 $T_t$

    从磁盘读出或向磁盘写入数据的时间。取决于每次读/写的字节数和磁盘的旋转速度（线性相关）。

    - 设一个磁道上的字节数为 $N$，
    - 每次读写的字节数为 $b$ 。
    - 则 $T_t = {b \over rN}$，其中，（${1 \over r}$）是转一圈的时间，${b \over N}$ 为比例。

  - 调度算法决定寻找时间（占大部分时间），从而决定总的存取时间。

- 性能指标

	- 平均寻找长度

- 先来先服务算法（FCFS）

- 最短寻找时间优先算法（SSTF）

	- 会产生“饥饿”现象。

- **扫描**算法（SCAN）

	- 又称电梯调度算法
	- 优先服务在磁头当前**移动方向上**，与当前磁道最近的请求。
	- 对最近扫描过的区域不公平，访问局部性不如 FCFS 和 SSTF 。

- **循环扫描**算法（C-SCAN）

  - 在 SCAN 的基础上，规定磁头**单向移动**，在回返时快速移动到起始端而不服务任何请求。
  - 注意，**快速回返**时移动的距离也要算磁头的移动距离。

- 改进算法

	- SCAN 和 C-SCAN 中，磁头都是严格从盘面一端到另一端，这可以改进，不必“到头”再“调转”。
	- 在给定一个方向移动前会查看是否有请求。
	- SCAN 改进：LOOK 调度
	- C-SCAN 改进：C-LOOK 调度
	- **可默认 SCAN 是 LOOK， C-SCAN 是 C-LOOK 。**

- 算法比较 王道P259

- 注意，寻道时，不能从最小号直接移动一步到最大号，因为寻道时的空间状态不是圆的，是在盘面半径上。

- 簇号和扇区号也可以做寻道算法的依据，也可以将其转换为磁道，若给出柱面之类，要对应到一个范围。 王道P264.7

- 由扇区号等取柱面号等要**取下整**。王道P264.7

- 磁盘调度算法是减少寻找时间。

- 也可减少延迟时间 王道P259

  - 对盘面扇区**交替编号**。
  - 对不同盘面**错位命名**。
  - 原因
  	- 磁头读写一个物理块后，需要有短暂的处理时间才能开始读写下一块。
  	- 读一个扇区需要完整转过这一个扇区，即磁头必须要完整扫过一个扇区才能读取完一个扇区。
  	- 在这短暂的时间中，磁盘仍然在旋转。

- 存在同一个柱面上的不同盘面不需要移动磁道，一般存在同一个柱面的不同盘面更好。

- **磁盘传输时间是磁盘本身性质所决定的，不能通过一定的措施减少。**

#### 磁盘的管理

- 磁盘初始化

  - 低级格式化（物理分区）

  	格式化每个扇区（头部，数据部分，尾部），其中，数据部分一般是 $512B$ 。

  - 操作系统

  	- 分区（逻辑分区）

  		对柱面格式化（即 C 盘、D 盘等形式的分区）

  	- 逻辑格式化（创建文件系统）
  	
  		包括空闲和已分配的空间以及一个初始为空的目录。

- 引导块

	- 自举程序

		计算机启动时需要运行一个初始化程序（自举程序），它初始化 CPU，寄存器，设备控制器和内存等，然后将磁盘上的操作系统装入内存，从而启动操作系统。

	- 自举装入程序

		通常在 ROM 中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘引导块上。

		引导块的位置是固定的。

	- 拥有启动分区的磁盘称为启动磁盘或系统磁盘。

- 坏块

	- 操作系统不能修复坏块，只能不去使用坏块。

## 输入输出管理（I/O 管理）

王道P272

### 基本结构

- I/O 设备

	- 块设备
		- 可寻址（即可随机地读写任一块）
	- 字符设备
		- 不可寻址
		- 常采用中断驱动方式

- I/O 控制方式

	- 程序直接控制方式
	- 中断驱动方式
		- 一次传送**一字节**。
	- DMA 方式
		- 一次传送**一块**。可以实现 CPU 和 I/O 设备的并行操作。
		- DMA（直接存储器存取）
		- 每个 DMA 控制器对应一台设备和内存。
	- 通道控制方式
		- 一次传送**多块**。可以实现 CPU、通道和 I/O 设备的并行操作。
		- I/O 通道是专门负责输入输出的处理机（属于硬件技术）。
		- 通道程序是放在主存中的。
		- 一个通道可以控制多台设备与内存的数据交换。

- I/O 子系统层次结构

	- 用户层 I/O 软件

	- 设备独立性软件

		逻辑设备，物理设备

	- 设备驱动程序

		- 每**类**设备只属于一个设备驱动程序。

	- 中断处理程序

	- 硬件

		- 设备控制器（I/O 逻辑，适配器）

- 杂项

	- 系统为每台设备确定一个编号以区分和识别设备，叫设备的绝对号。
	- 通道等控制设备控制器，设备控制器控制设备工作（都要经过设备控制器）。

### I/O 核心子系统

王道P283

#### I/O 调度

- 确定一个顺序执行 I/O 请求。
- 操作系统为每个设备维护一个请求队列来实现调度。
- 磁盘调度算法（寻道）就是 I/O 调度的一种。

#### 高速缓存与缓冲区

- 磁盘高速缓存
	- 逻辑上属于磁盘，
	- 物理上是内存中的盘块。
- 缓冲区
	- 基本概念
		- 缓和 CPU 与 I/O 设备间速度不匹配的问题。
		- 磁盘把一块数据输入缓冲区的时间为 $T$
		- 将缓冲区中的数据传送到用户进程（即传送到工作区供 CPU 处理）的时间为 $M$
		- CPU 对一块数据的处理时间为 $C$
	- 单缓冲
		- 处理每块数据的时间为 $\max(C,T) + M$
		- 输入（T）和处理（C）可同时进行。
		- 初始状态
			- 工作区满
			- 缓冲区空
	- 双缓冲
		- 处理每块数据的时间为 $\max(C+M, T)$
		- 输入（T）的同时可以进行处理（C）和传送（M）。
		- **这两个公式注意看王道 P285 的图，考虑并行关系，并行取大。**
		- 初始状态
			- 工作区空
			- 缓冲区一满一空
	- 注意
	  - 上面两个公式是在有**大量数据**的条件下的**平均**处理一块数据的时间，若有**具体的数据块数**，可以画**时序图**分析。 王道P292.14 P292.15
	  - 单缓冲和双缓冲都只有一个输入缓冲区进程和一个输入用户区进程（从缓冲区输出）
	- 循环缓冲
	  - 包含多个大小相等的缓冲区。
	  - 环链状
	  - 两个控制指针 in、out
	- 缓冲池
	  - 按照使用情况分成三个队列
	  	- 空缓冲队列
	  	- 输入队列
	  	- 输出队列
	  - 四种缓冲区
	  	- 针对输入（输入到用户程序）
	  		- 收容输入区
	  		- 提取输入区
	  	- 针对输出（从用户程序输出）
	  		- 收容输出区
	  		- 提取输出区
	- 高速缓存与缓冲区的对比 王道P287

#### 设备分配与回收

- 设备类型与使用方式

	- 独占设备

		独占式使用设备

	- 共享设备

		分时式共享使用设备

	- **虚拟设备**

		以 **SPOOLing 方式**使用外部设备（假脱机 I/O 技术）（以空间换时间）

- 设备分配的数据结构 王道P287

	- 设备控制表（DCT）
	- 控制器控制表（COCT）
	- 通道控制表（CHCT）
	- 系统设备表（SDT）

- 设备分配策略

	- 设备分配原则
	- 设备分配方式
		- 静态分配
		- 动态分配
	- 设备分配算法

- 逻辑设备名到物理设备名的映射

	- 逻辑设备表（LUT）

		两种设置 LUT 的方式

		- 整个系统设置一张 LUT

			不允许有相同逻辑设备名，适用于单用户系统。

		- 每个用户设置一张 LUT

			把该表放入进程的 PCB 。

- SPOOLing 技术（假脱机技术）

	- 缓和 CPU 高速性与 I/O 设备低速性的矛盾。

	- 是一项将独占设备改造为共享设备的技术。

	- 主要目的是提高独占资源的利用率。

	- 实现了**虚拟设备**功能。

	- 将低速设备的数据传送到高速的磁盘上暂存，或者相反，从而 CPU 可以从磁盘获取数据。

	- 在磁盘上开辟两个数据区域（井管理程序）

		- 输入井

			收容 I/O 设备输入的数据。

		- 输出井

			收容程序输出的数据。

	- 在内存上开辟两个缓冲区

	  - 输入缓冲区

	  	暂存低速 I/O 设备的输入数据，然后传送到输入井。

	  - 输出缓冲区

	  	暂存程序的输出数据，然后传送到输出井。
	  	
	  - 注意

	    - 只能说 SPOOLing 的数据首先是送入磁盘，不能说首先送入内存缓冲区，因为缓冲区只是一个短暂的过渡的手段（数据只是经过缓冲区）。

	- 建立两个进程

		- 输入进程（预输入程序）
	
			控制数据从输入缓冲区到输入井。
	
		- 输出进程（缓输出程序）
	
			控制数据从输出缓冲区到输出井。

